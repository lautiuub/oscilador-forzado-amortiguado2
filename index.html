<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Oscilador Forzado Amortiguado - Kinsler</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
  :root{ --bg:#f9f9f9; --card:#fff; --muted:#666; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 12px; background: var(--bg); color: #222; }
  h1{ text-align:center; margin:6px 0 8px 0; }
  #ui { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; margin-bottom:10px; padding: 10px; background: var(--card); border: 1px solid #eee; border-radius: 8px; }
  .control { display:flex; flex-direction:column; font-size:13px; align-items:center; }
  input[type=range]{ width:170px; }
  .btn { padding: 8px 12px; margin: 4px; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; color:#fff; }
  .btn.play { background:#2e7d32; } .btn.pause { background:#f9a825; color:#111; } .btn.reset { background:#c62828; }
  .scenario { background:#1976d2; }
  .panel{ background:var(--card); border:1px solid #eee; padding:10px; border-radius:8px; margin-bottom:10px; }
  canvas{ background:#fafafa; display:block; border-radius:6px; width:100%; }
  .row{ display:flex; gap:12px; flex-wrap:wrap; }
  .col{ flex:1; min-width:260px; }
  #eduToggle { position: fixed; top: 18px; right: 18px; z-index: 1001; padding:8px 12px; background:#006bb3; color:#fff; border-radius:6px; cursor:pointer; font-weight:700; }
  #eduBox { position: fixed; top: 64px; right: 18px; width: 520px; max-width:95vw; padding: 12px; background: rgba(255,255,255,0.98); border: 2px solid #006bb3; border-radius:8px; box-shadow: 0 6px 18px rgba(0,0,0,0.15); z-index: 1000; cursor: move; font-size: 14px; line-height: 1.45; }
  #eduBox.hidden { display:none; }
  .eduTabs{ display:flex; gap:6px; margin-bottom:8px; }
  .eduTabs button{ padding:6px 8px; border-radius:6px; border:1px solid #d6eaff; background:#eaf6ff; cursor:pointer; }
  .moreTheory{ font-size:13px; max-height:360px; overflow:auto; border:1px solid #e6eef8; background:#fbfeff; padding:10px; border-radius:6px; }
  @media (max-width:720px){ #eduBox{ width: 94vw; left:3vw; right:3vw; top:60px; } #eduToggle{ top:8px; right:8px; } }
</style>
</head>
<body>
<div id="eduToggle">TeorÃ­a</div>
<h1>Oscilador Forzado Amortiguado - Kinsler</h1>
<p style="text-align:center">VisualizaciÃ³n de la respuesta dinÃ¡mica en sistemas masa-resorte amortiguados forzados</p>

<div id="ui" class="panel">
  <div class="control"><label>m [kg] â€” <span id="vm">1.00</span></label>
    <input id="m" type="range" min="0.1" max="5" step="0.01" value="1"></div>
  <div class="control"><label>k [N/m] â€” <span id="vk">1000</span></label>
    <input id="k" type="range" min="50" max="5000" step="1" value="1000"></div>
  <div class="control"><label>Râ‚˜ [NÂ·s/m] â€” <span id="vr">5.00</span></label>
    <input id="r" type="range" min="0" max="50" step="0.1" value="5"></div>
  <div class="control"><label>Fâ‚€ [N] â€” <span id="vf">1.00</span></label>
    <input id="f0" type="range" min="0" max="5" step="0.01" value="1"></div>
  <div class="control"><label>Ï‰ (rad/s) â€” <span id="vomega">60.00</span></label>
    <input id="omega" type="range" min="1" max="200" step="0.1" value="60"></div>
  <div style="width:100%; margin-top:8px; text-align:center;">
    <button id="rigidezBtn" class="btn scenario">Control por Rigidez</button>
    <button id="resonanciaBtn" class="btn scenario">Resonancia</button>
    <button id="masaBtn" class="btn scenario">Control por Masa</button>
  </div>
  <div style="width:100%; margin-top:8px; text-align:center;">
    <button id="play" class="btn play">Play</button>
    <button id="pause" class="btn pause">Pausa</button>
    <button id="reset" class="btn reset">Reset</button>
  </div>
  <div style="width:100%; margin-top:8px; display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap;">
    <label><input type="checkbox" id="showAnalytic" checked> Mostrar analÃ­tica (normalizada)</label>
    <label><input type="checkbox" id="showNumeric" checked> Mostrar numÃ©rica</label>
    <label><input type="checkbox" id="showReference"> Mostrar referencia F(t) (cero)</label>
  </div>
  <div style="width:100%; margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:center;">
    <label>Velocidad fasores: <select id="phSpeedSel"><option value="visual">visual (lenta)</option><option value="real">Ï‰ real</option></select></label>
    <label>Fasores conjunto: <select id="phAllMode"><option value="equal">long. igual</option><option value="scaled">escala natural</option></select></label>
  </div>
<div style="width:100%; margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:center;">
  <label><input type="checkbox" id="autoscaleNumeric" checked> Auto-escala seÃ±ales numÃ©ricas</label>
  <label><input type="checkbox" id="linkScales" checked> Escala conjunta (x,v,a)</label>
</div>

<div style="width:100%; text-align:center; margin-top:6px;">
  <label>Zoom vertical seÃ±ales:
    <input id="zoomScale" type="range" min="0.5" max="5" step="0.1" value="1" style="width:160px;">
    Ã—<span id="vZoomScale">1.0</span>
  </label>
</div>


<div class="panel">
  <h3>AnimaciÃ³n â€” masa y resorte</h3>
  <canvas id="anim" style="height:180px;"></canvas>
</div>

<div class="panel">
  <h3>SeÃ±ales en el tiempo â€” superpuesta</h3>
  <canvas id="time_superposed" style="height:220px;"></canvas>
  <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
    <label><input type="radio" name="mode" value="numeric" id="mode_numeric"> NumÃ©rica (real)</label>
    <label><input type="radio" name="mode" value="analytic" id="mode_analytic"> AnalÃ­tica (normalizada)</label>
    <label><input type="radio" name="mode" value="both" id="mode_both" checked> Ambas</label>
  </div>
</div>

<div class="panel">
  <h3>Fasores â€” panel conjunto y especÃ­ficos</h3>
  <div class="row">
    <div class="col">
      <h4>Fasores: x, v, a, F (conjunto)</h4>
      <canvas id="ph_all" style="height:220px;"></canvas>
      <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
        <label><input type="checkbox" id="showFx" checked> x</label>
        <label><input type="checkbox" id="showFv" checked> v</label>
        <label><input type="checkbox" id="showFa" checked> a</label>
        <label><input type="checkbox" id="showFf" checked> F</label>
      </div>
    </div>
    <div class="col">
      <h4>Fasor x vs F</h4>
      <canvas id="ph_xf" style="height:160px;"></canvas>
      <h4 style="margin-top:8px">Fasor v vs F</h4>
      <canvas id="ph_vf" style="height:160px;"></canvas>
      <h4 style="margin-top:8px">Fasor a vs F</h4>
      <canvas id="ph_af" style="height:160px;"></canvas>
    </div>
  </div>
</div>

<div class="panel">
  <h3>Curva de amplitud â€” respuesta en frecuencia</h3>
  <canvas id="freq_response" style="height:240px;"></canvas>
  <p style="font-size:13px; color:#555; text-align:center;">
    |X(Ï‰)| = Fâ‚€/m / âˆš((Ï‰â‚€Â² âˆ’ Ï‰Â²)Â² + (Râ‚˜ Ï‰ / m)Â²)â€ƒâ€ƒ(seÃ±alada en rojo la Ï‰ actual)
  </p>
</div>




<div id="eduBox" class="hidden" title="Arrastrame">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <div style="font-weight:700; color:#004a80;">ExplicaciÃ³n (Kinsler â€” Cap.1)</div>
    <button id="eduClose" style="background:transparent;border:none;font-size:16px;cursor:pointer;">âœ•</button>
  </div>
  <div class="eduTabs">
    <button id="tabBtnK">Kinsler</button>
    <button id="tabBtnEM">AnalogÃ­a EM</button>
    <button id="tabBtnCalc">CÃ¡lculos</button>
  </div>

   <div class="moreTheory" id="tabK">
  <h4>Kinsler â€” Impedancia y fases</h4>

  <p>\( Z_m(\omega) = R_m + i\left( \omega m - \dfrac{k}{\omega} \right) \).
     Kinsler define la impedancia como la relaciÃ³n entre fuerza y velocidad:
     \( Z_m = \dfrac{F}{V} \).</p>

  <p>Velocidad: \( V = \dfrac{F_0}{Z_m} \).
     Desplazamiento: \( X = \dfrac{V}{i\omega} = \dfrac{F_0}{i\omega Z_m} \).</p>

  <p>Si \( Z_m = |Z_m| e^{i\theta} \), entonces las fases son:
     la velocidad \(V\) tiene fase \(-\theta\) respecto a \(F\);
     el desplazamiento \(X\) tiene fase \(-\theta - \pi/2\);
     y la aceleraciÃ³n \(A\) tiene fase \(-\theta - \pi\).</p>

  <p>Comportamientos por rÃ©gimen (Kinsler):</p>
  <ul>
    <li><b>Rigidez (bajas Ï‰):</b> la reactancia del resorte domina, la posiciÃ³n tiende a estar en fase con la fuerza aplicada.</li>
    <li><b>Resonancia (Ï‰ â‰ˆ Ï‰â‚€):</b> las reactancias inductiva y capacitiva mecÃ¡nicas se cancelan, la parte resistiva domina â†’ la velocidad queda en fase con la fuerza; mÃ¡xima transferencia de potencia.</li>
    <li><b>Masa (altas Ï‰):</b> la inercia domina y la aceleraciÃ³n queda en fase con la fuerza.</li>
  </ul>

  <p><b>Q</b> y ancho de banda: \( Q = \dfrac{\omega_0 m}{R_m} \).
     Kinsler discute cÃ³mo la energÃ­a se almacena y se disipa segÃºn estos parÃ¡metros y la forma de la curva de resonancia.</p>

  <p>Observaciones: todas las ecuaciones estÃ¡n presentadas tal como en Kinsler (Cap. 1).
     Las fases presentadas en los fasores son relativas a la fuerza de excitaciÃ³n
     \( F(t) = \Re\{ F_0 e^{i\omega t} \} \).</p>
</div>




  <div class="moreTheory" id="tabEM" style="display:none;">
    <h4>AnalogÃ­a con circuitos elÃ©ctricos (Kinsler)</h4>
    <p>Kinsler usa la analogÃ­a mecÃ¡nico-elÃ©ctrica para facilitar la comprensiÃ³n. La correspondencia mÃ¡s comÃºn es:</p>
    <ul>
      <li>Masa \(m\) â†” Inductancia \(L\): almacena energÃ­a cinÃ©tica (Â½ m vÂ² â†” Â½ L iÂ²).</li>
      <li>Resorte \(k\) â†” Capacitancia inversa \(1/C\) (o sea, \(k\) â†” \(1/C\)): almacena energÃ­a potencial (Â½ k xÂ² â†” Â½ C vÂ² si se adapta la variable).</li>
      <li>Amortiguamiento \(R_m\) â†” Resistencia \(R\): disipa energÃ­a.</li>
    </ul>
    <p>Impedancia mecÃ¡nica \(Z_m(\omega)\) y elÃ©ctrica \(Z(\omega)=R+i(\omega L - 1/(\omega C))\) comparten matemÃ¡ticamente la misma estructura: tÃ©rminos resistivos y reactivos que determinan fase, magnitud e intercambio de energÃ­a.</p>
    <p>Kinsler muestra que conceptos como potencia media, impedancia compleja, y resonancia se traducen directamente entre dominios, lo que permite usar intuiciones de circuitos RLC en problemas mecÃ¡nicos.</p>
  </div>
  <div class="moreTheory" id="tabCalc" style="display:none;">
    <h4>CÃ¡lculos en tiempo real</h4>
    <p>Los valores de impedancia, amplitudes y fases se calculan en tiempo real segÃºn los parÃ¡metros actuales.</p>
    <div id="calcValues"></div>
  </div>
</div>

<script>
// v1.13 â€” final: fasores +20%, flechas, eduBox plegable/arrastrable, contenidos ampliados.

// DOM refs
const m_s = document.getElementById('m'), k_s = document.getElementById('k'), r_s = document.getElementById('r'), f0_s = document.getElementById('f0'), omega_s = document.getElementById('omega');
const vm = document.getElementById('vm'), vk = document.getElementById('vk'), vr = document.getElementById('vr'), vf = document.getElementById('vf'), vomega = document.getElementById('vomega');
const playB = document.getElementById('play'), pauseB = document.getElementById('pause'), resetB = document.getElementById('reset');
const rigidezB = document.getElementById('rigidezBtn'), resonB = document.getElementById('resonanciaBtn'), masaB = document.getElementById('masaBtn');
const anim = document.getElementById('anim'); const time_superposed = document.getElementById('time_superposed');
const ph_all = document.getElementById('ph_all'), ph_xf = document.getElementById('ph_xf'), ph_vf = document.getElementById('ph_vf'), ph_af = document.getElementById('ph_af');
const freq_response = document.getElementById('freq_response');
const showAnalytic = document.getElementById('showAnalytic'), showNumeric = document.getElementById('showNumeric'), showReference = document.getElementById('showReference');
const phSpeedSel = document.getElementById('phSpeedSel'), phAllMode = document.getElementById('phAllMode');
const showFx = document.getElementById('showFx'), showFv = document.getElementById('showFv'), showFa = document.getElementById('showFa'), showFf = document.getElementById('showFf');
const autoscaleNumeric = document.getElementById('autoscaleNumeric');

const linkScales = document.getElementById('linkScales');
const zoomScale = document.getElementById('zoomScale');
const vZoomScale = document.getElementById('vZoomScale');


const eduToggle = document.getElementById('eduToggle'), eduBox = document.getElementById('eduBox'), eduClose = document.getElementById('eduClose');
const tabBtnK = document.getElementById('tabBtnK'), tabBtnEM = document.getElementById('tabBtnEM'), tabBtnCalc = document.getElementById('tabBtnCalc');
const tabK = document.getElementById('tabK'), tabEM = document.getElementById('tabEM'), tabCalc = document.getElementById('tabCalc');
const calcValues = document.getElementById('calcValues');

// initial state
let m=1,k=1000,Rm=5,F0=1,omega=60; vm.textContent=m.toFixed(2); vk.textContent=k; vr.textContent=Rm.toFixed(2); vf.textContent=F0.toFixed(2); vomega.textContent=omega.toFixed(2);
let x=0,v=0,t=0,dt=0.002;
// keep numeric scaling robust when switching visualization mode
let lastNumericNorms = null;
function resetNumericNorms() {
  // Si el modo de escala conjunta estÃ¡ activo, no reiniciamos las normas
  if (linkScales && linkScales.checked) return;
  lastNumericNorms = null;
}
document.querySelectorAll('input[name="mode"]').forEach(r=> r.addEventListener('change', ()=>{ resetNumericNorms(); }));
let running=false; let dataT=[], dataX=[], dataV=[], dataA=[]; const maxSamples=8000; const Tdisplay=6;

// phasor visual angle â€” advance only when running (pausa sincronizada)
let phAngle = 0;
const ARROW_SCALE = 1.2; // increase phasor lengths by 20%

// helpers
function setupCanvas(canvas){ const ratio = window.devicePixelRatio || 1; const w = Math.floor(canvas.clientWidth * ratio); const h = Math.floor(canvas.clientHeight * ratio); if(canvas.width !== w || canvas.height !== h){ canvas.width = w; canvas.height = h; } const ctx = canvas.getContext('2d'); ctx.setTransform(ratio,0,0,ratio,0,0); return ctx; }
window.addEventListener('resize', ()=>{ setupCanvas(anim); setupCanvas(time_superposed); setupCanvas(ph_all); setupCanvas(ph_xf); setupCanvas(ph_vf); setupCanvas(ph_af); });

// UI events
[m_s,k_s,r_s,f0_s,omega_s].forEach(el=>el.addEventListener('input', ()=>{ m=+m_s.value; k=+k_s.value; Rm=+r_s.value; F0=+f0_s.value; omega=+omega_s.value; vm.textContent=m.toFixed(2); vk.textContent=k; vr.textContent=Rm.toFixed(2); vf.textContent=F0.toFixed(2); vomega.textContent=omega.toFixed(2); updateCalc(); }));
resetNumericNorms(); // recalcular escala cuando cambian parÃ¡metros fÃ­sicos
drawFreqResponse();

// evento para actualizar el zoom visual
zoomScale.addEventListener('input', ()=>{
  vZoomScale.textContent = parseFloat(zoomScale.value).toFixed(1);
  drawAll(); // ðŸ” redibuja las seÃ±ales inmediatamente con el nuevo zoom
});


rigidezB.onclick = ()=> setScenario('rigidez'); resonB.onclick = ()=> setScenario('resonancia'); masaB.onclick = ()=> setScenario('masa');
function setScenario(type){ const omega0 = Math.sqrt(k/m); if(type==='rigidez') omega_s.value=(0.2*omega0).toFixed(6); if(type==='resonancia') omega_s.value=(omega0).toFixed(6); if(type==='masa') omega_s.value=(3*omega0).toFixed(6); m=+m_s.value; k=+k_s.value; omega=+omega_s.value; vomega.textContent=omega.toFixed(2); updateCalc(); }

// integrator
function derivs(tt, xx, vv){ const F = F0*Math.cos(omega*tt); return (F - Rm*vv - k*xx)/m; }
function rk4_step(){ const h=dt; const x0=x,v0=v,t0=t; const a1=derivs(t0,x0,v0); const x2=x0+0.5*h*v0, v2=v0+0.5*h*a1, a2=derivs(t0+0.5*h,x2,v2); const x3=x0+0.5*h*v2, v3=v0+0.5*h*a2, a3=derivs(t0+0.5*h,x3,v3); const x4=x0+h*v3, v4=v0+h*a3, a4=derivs(t0+h,x4,v4); x += (h/6)*(v0 + 2*v2 + 2*v3 + v4); v += (h/6)*(a1 + 2*a2 + 2*a3 + a4); t += h; }
function computeInstantA(tt, xx, vv){ const F = F0*Math.cos(omega*tt); return (F - Rm*vv - k*xx)/m; }

// drawing functions
function drawAnim(){ const ctx = setupCanvas(anim); ctx.clearRect(0,0,anim.clientWidth, anim.clientHeight); const baseX=80, baseY=anim.clientHeight/2; const scale=40; const xp = baseX + x*scale; ctx.fillStyle='#444'; ctx.fillRect(10, baseY-40, 20, 80); ctx.lineWidth=2; ctx.strokeStyle='#666'; drawSpring(ctx, baseX, baseY, xp); const Finst = F0*Math.cos(omega*t); const intensity = Math.min(1, Math.abs(Finst)/Math.max(1e-8,F0)); ctx.fillStyle = `rgba(33,150,243,${0.5+0.5*intensity})`; ctx.fillRect(xp-20, baseY-20, 40, 40); ctx.strokeStyle='#0b63a4'; ctx.lineWidth=1.5; ctx.strokeRect(xp-20, baseY-20, 40, 40); const arrowMax=50; const arrowLen = Math.max(-1, Math.min(1, Finst/Math.max(1e-8,F0)))*arrowMax; ctx.beginPath(); ctx.moveTo(xp+30, baseY); ctx.lineTo(xp+30+arrowLen, baseY); ctx.strokeStyle=(Finst>=0)? '#e91e63' : '#9c27b0'; ctx.lineWidth=4; ctx.lineCap='round'; ctx.stroke(); const headDir=(arrowLen>=0)?1:-1; const hx=xp+30+arrowLen, hy=baseY; ctx.beginPath(); ctx.moveTo(hx,hy); ctx.lineTo(hx-8*headDir, hy-6); ctx.lineTo(hx-8*headDir, hy+6); ctx.fillStyle=(Finst>=0)? '#e91e63' : '#9c27b0'; ctx.fill(); ctx.fillStyle='#222'; ctx.font='12px sans-serif'; ctx.textAlign='left'; const omega0=Math.sqrt(k/m); ctx.fillText('Ï‰ / Ï‰â‚€ = ' + (omega/omega0).toFixed(3), 10, 20); ctx.textAlign='right'; ctx.fillText('x (m) = ' + x.toFixed(4), anim.clientWidth-20, 20); ctx.fillText('t = ' + t.toFixed(2) + ' s', anim.clientWidth-20, 38);
}
function drawSpring(ctx, baseX, baseY, endX, amp=10, coils=12){ ctx.beginPath(); ctx.moveTo(baseX, baseY); const L = Math.max(10, endX-baseX-20); for(let i=0;i<coils;i++){ const xi = baseX + 10 + (i+1)/coils * L; const yi = baseY + ((i%2===0)? -amp : amp); ctx.lineTo(xi, yi); } ctx.lineTo(endX-20, baseY); ctx.stroke(); }

function drawTimeSuperposed(){ const ctx=setupCanvas(time_superposed); ctx.clearRect(0,0,time_superposed.clientWidth,time_superposed.clientHeight); const W=time_superposed.clientWidth, H=time_superposed.clientHeight; const marginLeft=48, marginRight=12, marginTop=12, marginBottom=36; ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H); ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.strokeRect(marginLeft, marginTop, W-marginLeft-marginRight, H-marginTop-marginBottom);
  // compute analytic phasors correctly
  const safeOmega = Math.max(1e-8, omega);
  const Zr = Rm, Zi = omega*m - (k/safeOmega); const Zmag = Math.sqrt(Zr*Zr + Zi*Zi);
  const Vre = (F0 * Zr)/(Zmag*Zmag);
  const Vim = (-F0 * Zi)/(Zmag*Zmag);
  const Xre = Vim / safeOmega;
  const Xim = -Vre / safeOmega;
  const samples = 500; const period = 2*Math.PI/Math.max(1e-8, omega); const tWindow = Math.min(6, Math.max(period,1.0)); const t0 = (dataT.length>0)? dataT[dataT.length-1] : t; const tStart = t0 - tWindow;
  const ax = new Array(samples), av = new Array(samples), aa = new Array(samples), at = new Array(samples);
  for(let i=0;i<samples;i++){ const tt = tStart + (i/(samples-1))*tWindow; at[i]=tt; const cosw = Math.cos(omega*tt), sinw = Math.sin(omega*tt); const xval = Xre*cosw - Xim*sinw; const vval = safeOmega * ( - Xre * sinw - Xim * cosw ); const aval = - (safeOmega*safeOmega) * ( Xre*cosw - Xim*sinw ); ax[i]=xval; av[i]=vval; aa[i]=aval; }
  const maxAbsX = Math.max(...ax.map(Math.abs)), maxAbsV = Math.max(...av.map(Math.abs)), maxAbsA = Math.max(...aa.map(Math.abs)); const nX = Math.max(1e-8, maxAbsX), nV = Math.max(1e-8, maxAbsV), nA = Math.max(1e-8, maxAbsA);
  ctx.fillStyle = '#f9f9f9'; ctx.fillRect(marginLeft+1, marginTop+1, W - marginLeft - marginRight-2, H - marginTop - marginBottom-2);
  const mode = document.querySelector('input[name="mode"]:checked').value;
  if((mode==='analytic' || mode==='both') && showAnalytic.checked){ function drawAnalytic(arr,norm,color){ ctx.beginPath(); for(let i=0;i<arr.length;i++){ const sx = marginLeft + (i/(arr.length-1))*(W - marginLeft - marginRight); const sy = marginTop + (H - marginTop - marginBottom)/2 - (arr[i]/norm)*((H - marginTop - marginBottom)/2)*0.85; if(i===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy); } ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke(); }
    drawAnalytic(ax, nX, '#1565c0'); drawAnalytic(av, nV, '#4caf50'); drawAnalytic(aa, nA, '#ff9800'); }
  if((mode==='numeric' || mode==='both') && showNumeric.checked){ if(dataT.length>1){ const N=Math.min(dataT.length, 800); const tstart=dataT[dataT.length-N], tend=dataT[dataT.length-1]; const dtwin=Math.max(1e-8, tend - tstart);
      let normX=1, normV=1, normA=1; if(lastNumericNorms){ normX=lastNumericNorms.normX; normV=lastNumericNorms.normV; normA=lastNumericNorms.normA; }
      if (autoscaleNumeric && autoscaleNumeric.checked) {
  if (linkScales && linkScales.checked) {
    // Escala conjunta (todas las seÃ±ales comparten la misma norma)
    const maxAbsAll = Math.max(
      1e-6,
      Math.max(...dataX.map(Math.abs)),
      Math.max(...dataV.map(Math.abs)),
      Math.max(...dataA.map(Math.abs))
    );
    normX = normV = normA = maxAbsAll;
    lastNumericNorms = { normX, normV, normA };
  } else {
    // Escala independiente (comportamiento original)
    normX = Math.max(1e-6, Math.max(...dataX.map(Math.abs)));
    normV = Math.max(1e-6, Math.max(...dataV.map(Math.abs)));
    normA = Math.max(1e-6, Math.max(...dataA.map(Math.abs)));
    lastNumericNorms = { normX, normV, normA };
  }
}
      else { /* show raw values (real view) â€” do not normalize by last sample */ normX = 1; normV = 1; normA = 1; }
      // draw numeric signals as connected lines (better for scaling and mobile). If very sparse, draw points.
      function drawNumeric(drawArr, norm, color) {
  const zoom = parseFloat(zoomScale.value) || 1;  // âœ… calcular una sola vez por frame

  if (drawArr.length < 2) {
    for (let i = 0; i < drawArr.length; i++) {
      const sx = marginLeft + ((dataT[dataT.length - N + i] - tstart) / dtwin) * (W - marginLeft - marginRight);
      const sy = marginTop + (H - marginTop - marginBottom) / 2
               - (drawArr[i] / norm) * ((H - marginTop - marginBottom) / 2) * 0.85 * zoom;
      ctx.fillStyle = color;
      ctx.fillRect(sx - 1.5, sy - 1.5, 3, 3);
    }
    return;
  }

  ctx.beginPath();
  for (let i = 0; i < drawArr.length; i++) {
    const sx = marginLeft + ((dataT[dataT.length - N + i] - tstart) / dtwin) * (W - marginLeft - marginRight);
    const sy = marginTop + (H - marginTop - marginBottom) / 2
             - (drawArr[i] / norm) * ((H - marginTop - marginBottom) / 2) * 0.85 * zoom;
    if (i === 0) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = color;
  ctx.stroke();
}

      // call for x, v, a
      drawNumeric(dataX.slice(-N), normX, 'rgba(21,101,192,0.9)');
      drawNumeric(dataV.slice(-N), normV, 'rgba(76,175,80,0.9)');
      drawNumeric(dataA.slice(-N), normA, 'rgba(255,152,0,0.9)');
    }
  }
  ctx.fillStyle='#222'; ctx.font='12px sans-serif'; ctx.textAlign='left'; ctx.fillText('x (azul)   v (verde)   a (naranja)', marginLeft, H-22);
  if(showReference.checked){ const n = Math.round((omega*t0/(Math.PI)-0.5)/2); const tzc = ((2*n+1)*Math.PI)/(2*omega); if(tzc >= tStart && tzc <= t0){ const frac = (tzc - tStart)/tWindow; const sx = marginLeft + frac*(W-marginLeft-marginRight); ctx.strokeStyle='#aa0000'; ctx.lineWidth=1.2; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(sx, marginTop); ctx.lineTo(sx, H-marginBottom); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle='#aa0000'; ctx.fillText('Cero F(t)', sx+6, marginTop+12); } }
}

// phasor drawings (corrected physics and increased size + arrowheads)
function computeImpedance(){ const safeOmega = Math.max(1e-8, omega); const Zr = Rm; const Zi = safeOmega*m - (k/safeOmega); return {Zr, Zi, Zmag: Math.sqrt(Zr*Zr + Zi*Zi)}; }

function drawPhasorPanels(){ const ctxAll = setupCanvas(ph_all); ctxAll.clearRect(0,0,ph_all.clientWidth, ph_all.clientHeight);
  const imp = computeImpedance(); const Zr=imp.Zr, Zi=imp.Zi, Zmag=imp.Zmag; const Vre = (F0 * Zr)/(Zmag*Zmag); const Vim = (-F0 * Zi)/(Zmag*Zmag);
  const Xre = Vim / Math.max(1e-8, omega); const Xim = -Vre / Math.max(1e-8, omega);
  const Are = -omega*omega * Xre; const Aim = -omega*omega * Xim;
  const Fph = { re: F0, im: 0 };
  const Vph = { re: Vre, im: Vim };
  const Xph = { re: Xre, im: Xim };
  const Aph = { re: Are, im: Aim };
  if(running){ const rotSpeed = (phSpeedSel.value==='real')? omega : 1.6; phAngle += rotSpeed * 0.016; }
  const cx = ph_all.clientWidth/2, cy = ph_all.clientHeight/2; const baseScale = Math.min(ph_all.clientWidth, ph_all.clientHeight)/4;
  const magX = Math.hypot(Xph.re,Xph.im), magV = Math.hypot(Vph.re,Vph.im), magA = Math.hypot(Aph.re,Aph.im), magF = Math.hypot(Fph.re,Fph.im);
  const maxMag = Math.max(magX, magV, magA, magF, 1e-8);
  const sX = (phAllMode.value==='equal')? baseScale*0.85*ARROW_SCALE : baseScale*(magX/maxMag)*ARROW_SCALE;
  const sV = (phAllMode.value==='equal')? baseScale*0.85*ARROW_SCALE : baseScale*(magV/maxMag)*ARROW_SCALE;
  const sA = (phAllMode.value==='equal')? baseScale*0.85*ARROW_SCALE : baseScale*(magA/maxMag)*ARROW_SCALE;
  const sF = (phAllMode.value==='equal')? baseScale*0.85*ARROW_SCALE : baseScale*(magF/maxMag)*ARROW_SCALE;
  ctxAll.strokeStyle='#ddd'; ctxAll.lineWidth=1; ctxAll.beginPath(); ctxAll.moveTo(20,cy); ctxAll.lineTo(ph_all.clientWidth-20, cy); ctxAll.moveTo(cx,20); ctxAll.lineTo(cx, ph_all.clientHeight-20); ctxAll.stroke();
  function drawPh(cpl, scaleLen, color, show){ if(!show) return; const ang = Math.atan2(cpl.im, cpl.re) + phAngle; const xend = cx + Math.cos(ang)*scaleLen; const yend = cy - Math.sin(ang)*scaleLen; ctxAll.beginPath(); ctxAll.moveTo(cx,cy); ctxAll.lineTo(xend,yend); ctxAll.strokeStyle=color; ctxAll.lineWidth=3; ctxAll.stroke(); // arrow head
    const headSize=10; const backX = xend - Math.cos(ang)*headSize; const backY = yend + Math.sin(ang)*headSize; ctxAll.beginPath(); ctxAll.moveTo(xend,yend); ctxAll.lineTo(backX + Math.sin(ang)*6, backY + Math.cos(ang)*6); ctxAll.lineTo(backX - Math.sin(ang)*6, backY - Math.cos(ang)*6); ctxAll.closePath(); ctxAll.fillStyle=color; ctxAll.fill(); }
  drawPh(Xph,sX,'#1565c0',showFx.checked); drawPh(Vph,sV,'#4caf50',showFv.checked); drawPh(Aph,sA,'#ff9800',showFa.checked); drawPh(Fph,sF,'#e91e63',showFf.checked);
  ctxAll.fillStyle='#222'; ctxAll.font='12px sans-serif'; ctxAll.fillText('Fasores (origen comÃºn) â€” referencia: F (rosa)', 24, 18);
  // individuals
  drawPhSingle(ph_xf, Xph, Fph, sX, sF, '#1565c0','#e91e63'); drawPhSingle(ph_vf, Vph, Fph, sV, sF, '#4caf50','#e91e63'); drawPhSingle(ph_af, Aph, Fph, sA, sF, '#ff9800','#e91e63'); }

function drawPhSingle(canvasEl, ph1, ph2, len1, len2, color1, color2){ const ctx = setupCanvas(canvasEl); ctx.clearRect(0,0,canvasEl.clientWidth, canvasEl.clientHeight); const cx = canvasEl.clientWidth/2, cy = canvasEl.clientHeight/2; ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(10,cy); ctx.lineTo(canvasEl.clientWidth-10, cy); ctx.moveTo(cx,10); ctx.lineTo(cx, canvasEl.clientHeight-10); ctx.stroke(); function drawVec(cpl,len,color){ const ang = Math.atan2(cpl.im,cpl.re) + phAngle; const xend = cx + Math.cos(ang)*len; const yend = cy - Math.sin(ang)*len; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(xend,yend); ctx.strokeStyle=color; ctx.lineWidth=3; ctx.stroke(); const headSize = 9; const backX = xend - Math.cos(ang)*headSize; const backY = yend + Math.sin(ang)*headSize; ctx.beginPath(); ctx.moveTo(xend,yend); ctx.lineTo(backX + Math.sin(ang)*5, backY + Math.cos(ang)*5); ctx.lineTo(backX - Math.sin(ang)*5, backY - Math.cos(ang)*5); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); }
  drawVec(ph2,len2,color2); drawVec(ph1,len1,color1); }

function drawFreqResponse() {
  const ctx = setupCanvas(freq_response);
  const W = freq_response.clientWidth, H = freq_response.clientHeight;
  ctx.clearRect(0, 0, W, H);

  // MÃ¡rgenes
  const marginLeft = 50, marginRight = 20, marginTop = 10, marginBottom = 36;
  const plotW = W - marginLeft - marginRight;
  const plotH = H - marginTop - marginBottom;

  // Ejes
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 1;
  ctx.strokeRect(marginLeft, marginTop, plotW, plotH);

  // ParÃ¡metros
  const omega0 = Math.sqrt(k / m);
  const omegaMin = 0.05 * omega0;
  const omegaMax = 3.5 * omega0;
  const n = 400;
  const xVals = new Array(n), yVals = new Array(n);
  let yMax = 0;

  for (let i = 0; i < n; i++) {
    const w = omegaMin + (i / (n - 1)) * (omegaMax - omegaMin);
    const num = F0 / m;
    const den = Math.sqrt((omega0 * omega0 - w * w) ** 2 + ((Rm * w) / m) ** 2);
    const amp = num / den;
    xVals[i] = w;
    yVals[i] = amp;
    if (amp > yMax) yMax = amp;
  }

  // Curva
  ctx.beginPath();
  for (let i = 0; i < n; i++) {
    const sx = marginLeft + (xVals[i] - omegaMin) / (omegaMax - omegaMin) * plotW;
    const sy = marginTop + plotH * (1 - yVals[i] / yMax);
    if (i === 0) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  ctx.strokeStyle = "#1565c0";
  ctx.lineWidth = 2;
  ctx.stroke();

  // LÃ­nea de Ï‰ actual
  const sxCur = marginLeft + (omega - omegaMin) / (omegaMax - omegaMin) * plotW;
  ctx.beginPath();
  ctx.moveTo(sxCur, marginTop);
  ctx.lineTo(sxCur, marginTop + plotH);
  ctx.strokeStyle = "#d32f2f";
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 3]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Etiquetas
  ctx.fillStyle = "#222";
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Frecuencia Ï‰ (rad/s)", marginLeft + plotW / 2, H - 10);
  ctx.save();
  ctx.translate(16, marginTop + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.fillText("|X(Ï‰)| (m)", 0, 0);
  ctx.restore();
}



// main loop
function step(){ rk4_step(); const ainst = computeInstantA(t,x,v); dataT.push(t); dataX.push(x); dataV.push(v); dataA.push(ainst); if(dataT.length>maxSamples){ dataT.shift(); dataX.shift(); dataV.shift(); dataA.shift(); } }
function drawAll(){
  drawAnim();
  drawTimeSuperposed();
  drawPhasorPanels();
  drawFreqResponse();   // nueva curva de amplitud
  updateCalc();
}
function loop(){ if(running){ for(let i=0;i<4;i++) step(); } drawAll(); requestAnimationFrame(loop); }
loop();

// controls
playB.onclick = ()=> { running=true; };
pauseB.onclick = ()=> { running=false; };
resetB.onclick = ()=> { m_s.value=1; k_s.value=1000; r_s.value=5; f0_s.value=1; omega_s.value=60; m=1;k=1000;Rm=5;F0=1;omega=60; vm.textContent=m.toFixed(2); vk.textContent=k; vr.textContent=Rm.toFixed(2); vf.textContent=F0.toFixed(2); vomega.textContent=omega.toFixed(2); running=false; x=0; v=0; t=0; dataT=[]; dataX=[]; dataV=[]; dataA=[]; }

// tabs logic
eduToggle.onclick = ()=>{ eduBox.classList.toggle('hidden'); if(window.MathJax && !eduBox.classList.contains('hidden')){ MathJax.typesetPromise([eduBox]).catch(()=>{}); } };
eduClose.onclick = ()=>{ eduBox.classList.add('hidden'); };
tabBtnK.onclick = ()=>{ tabK.style.display='block'; tabEM.style.display='none'; tabCalc.style.display='none'; if(window.MathJax){ MathJax.typesetPromise([tabK]).catch(()=>{}); } };
tabBtnEM.onclick = ()=>{ tabK.style.display='none'; tabEM.style.display='block'; tabCalc.style.display='none'; if(window.MathJax){ MathJax.typesetPromise([tabEM]).catch(()=>{}); } };
tabBtnCalc.onclick = ()=>{ tabK.style.display='none'; tabEM.style.display='none'; tabCalc.style.display='block'; updateCalc(); if(window.MathJax){ MathJax.typesetPromise([tabCalc]).catch(()=>{}); } };
// draggable eduBox
let dragging=false, offX=0, offY=0; eduBox.addEventListener('mousedown', e=>{ dragging=true; offX=e.offsetX; offY=e.offsetY; }); window.addEventListener('mouseup', ()=>dragging=false); window.addEventListener('mousemove', e=>{ if(dragging && !eduBox.classList.contains('hidden')){ eduBox.style.left = Math.max(4, e.pageX - offX) + 'px'; eduBox.style.top = Math.max(4, e.pageY - offY) + 'px'; eduBox.style.right='auto'; } });

// calculations
function updateCalc(){ const safeOmega = Math.max(1e-8, omega); const imp = computeImpedance(); const theta = Math.atan2(imp.Zi, imp.Zr); const deg = (theta*180/Math.PI).toFixed(2); const Vre = (F0 * imp.Zr)/(imp.Zmag*imp.Zmag); const Vim = (-F0 * imp.Zi)/(imp.Zmag*imp.Zmag); const Vmag = Math.sqrt(Vre*Vre + Vim*Vim); const Vphase = (Math.atan2(Vim, Vre)*180/Math.PI).toFixed(2); const Xre = Vim/Math.max(1e-8,omega); const Xim = -Vre/Math.max(1e-8,omega); const Xmag = Math.sqrt(Xre*Xre + Xim*Xim); const Xphase = (Math.atan2(Xim, Xre)*180/Math.PI).toFixed(2); const omega0 = Math.sqrt(k/m); const Q = (omega0*m)/Math.max(1e-8,Rm);
  calcValues.innerHTML = `<ul><li>|Z| = ${imp.Zmag.toFixed(4)}</li><li>fase Z = ${deg}Â°</li><li>|V| = ${Vmag.toFixed(6)} m/s, fase V = ${Vphase}Â°</li><li>|X| = ${Xmag.toExponential(3)} m, fase X = ${Xphase}Â°</li><li>Ï‰â‚€ = ${omega0.toFixed(3)} rad/s</li><li>Q = ${Q.toFixed(2)}</li></ul>`;
}

// init
updateCalc();
</script>
</body>
</html>